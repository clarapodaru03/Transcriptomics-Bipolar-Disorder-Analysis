zero_col_v6
matrix_v6_clean <- matrix_v6[, !colnames(matrix_v6) %in% zero_col_v6]
CIBERSORTx_Mixtures_Adjusted_v8 <- read.delim("~/TFG/cibersortx/dataoutput/CIBERSORTx_Mixtures_Adjusted_v8.txt", header=FALSE)
View(CIBERSORTx_Mixtures_Adjusted_v8)
CIBERSORTx_Mixtures_Adjusted_v8 <- read.delim("~/TFG/cibersortx/dataoutput/CIBERSORTx_Mixtures_Adjusted_v8.txt", header=FALSE)
View(CIBERSORTx_Mixtures_Adjusted_v8)
CIBERSORTx_Adjusted_v8 <- read.delim("~/TFG/cibersortx/dataoutput/CIBERSORTx_Adjusted_v8.txt", header=FALSE)
View(CIBERSORTx_Adjusted_v8)
# Cargar datos
c_file <- 'config_file.txt'
configfile <- read.table(imp_file, header = TRUE, sep = "\t", stringsAsFactors = FALSE)
configfile <- read.table(c_file, header = TRUE, sep = "\t", stringsAsFactors = FALSE)
# Cargar datos
c_file <- 'config_file.txt'
configfile <- read.table(c_file, header = TRUE, sep = "\t", stringsAsFactors = FALSE)
# Configurar directorio de trabajo
workingD <- rstudioapi::getActiveDocumentContext()$path
setwd(dirname(workingD))
# Cargar datos
c_file <- 'config_file.txt'
configfile <- read.table(c_file, header = TRUE, sep = "\t", stringsAsFactors = FALSE)
# Cargar matriz de datos de cibersortx
r_file <- 'V9.txt'
cibersort_results <- read.table(r_file, header = TRUE, sep = "\t", stringsAsFactors = FALSE)
View(cibersort_results)
# Importar librerías
library(dplyr)
View(cibersort_results)
View(configfile)
# añadir nueva columna a cibersort results
cibersort_results['sex'] = configfile['sex'].values
# Fusionar con los datos de expresión
df_merge <- cibersort_results %>%
left_join(configfile, by = c("mixture" = "samples"))
configfile$status <- cibersort_results$sex
View(cibersort_results)
View(configfile)
source("~/TFG/cibersortx/data/final_data/cor_pilot_data.R")
View(df_merged)
View(df_merged)
source("~/TFG/cibersortx/data/final_data/cor_pilot_data.R")
View(df_merged)
# Convertir sex y status a factores
df_merged$sex <- factor(df_merged$sex, levels = c(1, 2), labels = c("M", "F"))
df_merged$status <- factor(df_merged$status, levels = c(1, 2), labels = c("Unaffected", "Affected"))
View(df_merged)
df_merged$status <- factor(df_merged$status, levels = c(1, 2), labels = c("Unaffected", "Affected"))
u
# Correlación o ANOVA por sexo
results_sex <- apply(df_merged, 2, function(cell_type) {
t_test_result <- t.test(cell_type ~ df_merged$sex)  # t-test entre hombre y mujer
return(t_test_result$p.value)  # Retornar el valor p
})
# Cargar config file (metadatos)
c_file <- 'config_file.txt'
configfile <- read.table(c_file, header = TRUE, sep = "\t", stringsAsFactors = FALSE)
# Cargar matriz de datos de cibersortx
r_file <- 'V9.txt'
cibersort_results <- read.table(r_file, header = TRUE, sep = "\t", stringsAsFactors = FALSE)
df_merged <- cibersort_results %>%
mutate(sex = configfile$sex, affstatus = configfile$status)
# Correlación o ANOVA por sexo
results_sex <- apply(df_merged, 2, function(cell_type) {
t_test_result <- t.test(cell_type ~ df_merged$sex)  # t-test entre hombre y mujer
return(t_test_result$p.value)  # Retornar el valor p
})
# Correlación o ANOVA por sexo
results_sex <- apply(df_merged[, 1:21], 2, function(cell_type) {
# Realizar t-test entre los tipos celulares (por sexo)
t_test_result <- t.test(cell_type ~ df_merged$sex)
return(t_test_result$p.value)  # Retornar el valor p
})
# Correlación o ANOVA por sexo
results_sex <- apply(df_merged[, 1:21], 2, function(cell_type) {
# Realizar t-test entre los tipos celulares (por sexo)
t_test_result <- t.test(cell_type ~ df_merged$sex)
return(t_test_result$p.value)  # Retornar el valor p
})
# Configurar directorio de trabajo
workingD <- rstudioapi::getActiveDocumentContext()$path
setwd(dirname(workingD))
# Load libraries
library(dplyr)
library(ggplot2)
library(corrplot)
install.packages("corrplot")
library(corrplot)
# Read metadata (config_file)
meta_data <- read.table("config_file.txt", header = TRUE, sep = "\t", stringsAsFactors = FALSE)
# Read cibersortx ouput
cibersortx_results <- read.table("V9.txt", header = TRUE, sep = "\t", stringsAsFactors = FALSE)
# Ensure the column names are read correctly
colnames(meta_data) <- c("sample", "path", "status", "sex")
colnames(cibersortx_results)[1] <- "sample" # rename the first column so that it matches the one from meta_data
View(cibersortx_results)
View(meta_data)
# Merge both datasets
dataa <- merge(cibersortx_results, meta_data, by = "sample")
View(dataa)
dataa$status <- factor(dataa$status, labels = c("Control", "Bipolar"))
dataa$sex <- factor(dataa$sex, labels = c("Male", "Female"))
# Choose only the numerical columns (cell types)
cell_types <- dataa %>% select(-c(sample, path, P.value, Correlation, RMSE, status))
# Choose only the numerical columns (cell types)
cell_types <- dataa %>% select(-c(sample, path, P.value, Correlation, RMSE, status))
install.packages("psych")
library(psych)
# Choose only the numerical columns (cell types)
cell_types <- dataa %>% select(-c(sample, path, P.value, Correlation, RMSE, status))
# Choose only the numerical columns (cell types)
cell_types <- dataa[, !(names(dataa) %in% c("sample", "path", "P.value", "Correlation", "RMSE", "status"))]
# Encode sex as a numeric valie (Male = 0, Female = 1)
dataa$sex <- as.numeric(dataa$sex) - 1
# Choose only the numerical columns (cell types)
cell_types <- dataa[, !(names(dataa) %in% c("sample", "path", "P.value", "Correlation", "RMSE", "status"))]
# Encode sex as a numeric valie (Male = 0, Female = 1)
dataa$sex_numeric <- as.numeric(dataa$sex) - 1
# Read metadata (config_file)
meta_data <- read.table("config_file.txt", header = TRUE, sep = "\t", stringsAsFactors = FALSE)
# Read cibersortx ouput
cibersortx_results <- read.table("V9.txt", header = TRUE, sep = "\t", stringsAsFactors = FALSE)
# Ensure the column names are read correctly
colnames(meta_data) <- c("sample", "path", "status", "sex")
colnames(cibersortx_results)[1] <- "sample" # rename the first column so that it matches the one from meta_data
# Merge both datasets
dataa <- merge(cibersortx_results, meta_data, by = "sample")
dataa$status <- factor(dataa$status, labels = c("Control", "Bipolar"))
dataa$sex <- factor(dataa$sex, labels = c("Male", "Female"))
# Choose only the numerical columns (cell types)
cell_types <- dataa[, !(names(dataa) %in% c("sample", "path", "P.value", "Correlation", "RMSE", "status"))]
# Encode sex as a numeric valie (Male = 0, Female = 1)
dataa$sex_numeric <- as.numeric(dataa$sex) - 1
# Compute correlations
corr_sex <- cor(cell_types, dataa$sex_numeric)
# Encode sex as a numeric valie (Male = 0, Female = 1)
dataa$sex_numeric <- as.numeric(dataa$sex) - 1
# Compute correlations
corr_sex <- cor(cell_types, dataa$sex_numeric, use = "pairwise.complete.obs")
View(dataa)
str(cell_types)
dataa$sex_numeric <- as.numeric(dataa$sex) - 1  # Converts "Male"=0, "Female"=1
# Compute correlations
corr_sex <- cor(cell_types, dataa$sex_numeric, use = "pairwise.complete.obs")
# Encode sex as a numeric valie (Male = 0, Female = 1)
dataa$sex_numeric <- as.numeric(as.character(dataa$sex)) - 1  # Converts "Male"=0, "Female"=1
# Encode sex as a numeric valie (Male = 0, Female = 1)
data$sex_numeric <- as.numeric(data$sex) - 1  # Works only if factor is correctly set
# Encode sex as a numeric valie (Male = 0, Female = 1)
dataa$sex_numeric <- as.numeric(dataa$sex) - 1  # Works only if factor is correctly set
# Compute correlations
corr_sex <- cor(cell_types, dataa$sex_numeric, use = "pairwise.complete.obs")
table(dataa$sex, dataa$sex_numeric)
# Compute correlations
corr_sex <- cor(cell_types, dataa$sex_numeric, use = "pairwise.complete.obs")
str(cell_types)
# Choose only the numerical columns (cell types)
cell_types <- dataa[, !(names(dataa) %in% c("sample", "path", "P.value", "Correlation", "RMSE", "status", "sex"))]
# Encode sex as a numeric valie (Male = 0, Female = 1)
dataa$sex_numeric <- as.numeric(dataa$sex) - 1  # Works only if factor is correctly set
# Compute correlations
corr_sex <- cor(cell_types, dataa$sex_numeric, use = "pairwise.complete.obs")
# Convert sex to a factor
dataa$sex <- as.factor(dataa$sex)
cell_types <- dataa %>%
select(-c(sample, path, P.value, Correlation, RMSE, status, sex)) %>%
mutate(across(everything(), as.numeric))
# Ensure cell_types contains only numeric values
cell_types <- dataa[, !(names(dataa) %in% c("sample", "path", "P.value", "Correlation", "RMSE", "status", "sex"))]
# Apply Wilcoxon test to every cell  type
wilcoxon_results <- apply(cell_types, 2, function(x) wilcox.test(x ~ dataa$sex))
warnings()
# Apply Wilcoxon test to every cell  type
wilcoxon_results <- apply(cell_types, 2, function(x) wilcox.test(x ~ dataa$sex, exact = FALSE))
# Extract the p values
wilcoxon_p_values <- sapply(wilcoxon_results, function(x) x$p.value)
# Filter cell types with significant differences (p < 0.05)
significant_cell <- names(wilcoxon_p_values[wilcoxon_p_values < 0.05])
# Show the cell types with significant differences
print(significant_cell)
library(dplyr)
library(ggplot2)
library(corrplot)
library(psych)
# Read metadata (config_file)
meta_data <- read.table("config_file.txt", header = TRUE, sep = "\t", stringsAsFactors = FALSE)
# Read cibersortx ouput
cibersortx_results <- read.table("V9.txt", header = TRUE, sep = "\t", stringsAsFactors = FALSE)
# Ensure the column names are read correctly
colnames(meta_data) <- c("sample", "path", "status", "sex")
colnames(cibersortx_results)[1] <- "sample" # rename the first column so that it matches the one from meta_data
# Merge both datasets
dataa <- merge(cibersortx_results, meta_data, by = "sample")
dataa$status <- factor(dataa$status, labels = c("Control", "Bipolar"))
dataa$sex <- factor(dataa$sex, labels = c("Male", "Female"))
# Convert sex to a factor
dataa$sex <- as.factor(dataa$sex)
# Ensure cell_types contains only numeric values
cell_types <- dataa[, !(names(dataa) %in% c("sample", "path", "P.value", "Correlation", "RMSE", "status", "sex"))]
# Apply Wilcoxon test to every cell  type
wilcoxon_results <- apply(cell_types, 2, function(x) wilcox.test(x ~ dataa$sex, exact = FALSE))
# Extract the p values
wilcoxon_p_values <- sapply(wilcoxon_results, function(x) x$p.value)
# Filter cell types with significant differences (p < 0.05)
significant_cell <- names(wilcoxon_p_values[wilcoxon_p_values < 0.05])
# Show the cell types with significant differences
print(significant_cell)
model <- glm(sex ~ ., data = cell_types, family = binomial)
meta_data <- read.table("config_file.txt", header = TRUE, sep = "\t", stringsAsFactors = FALSE)
# Read cibersortx ouput
cibersortx_results <- read.table("V9.txt", header = TRUE, sep = "\t", stringsAsFactors = FALSE)
# Ensure the column names are read correctly
colnames(meta_data) <- c("sample", "path", "status", "sex")
colnames(cibersortx_results)[1] <- "sample" # rename the first column so that it matches the one from meta_data
# Merge both datasets
dataa <- merge(cibersortx_results, meta_data, by = "sample")
dataa$status <- factor(dataa$status, labels = c("Control", "Bipolar"))
dataa$sex <- factor(dataa$sex, labels = c("Male", "Female"))
str(dataa$sex)
cell_types <- dataa[, !(names(dataa) %in% c("sample", "path", "P.value", "Correlation", "RMSE", "status", "sex"))]
# Ensure cell_types contains only numeric values
cell_types <- dataa[, !(names(dataa) %in% c("sample", "path", "P.value", "Correlation", "RMSE", "status"))]
model <- glm(sex ~ ., data = cell_types, family = binomial)
summary(model)
install.packages("glmnet")
library(glmnet)
# Convert Sex to numeric
cell_types$sex_numeric <- as.numeric(cell_types$sex) - 1
# Adjust
x <- as.matrix(cell_types[, !(names(cell_types) %in% c("sex", "sex_numeric"))])  # Variables predictoras
y <- cell_types$sex_numeric  # Variable dependiente
# Modelo LASSO (alpha = 1) con validación cruzada
cv_model <- cv.glmnet(x, y, family = "binomial", alpha = 1)
# Modelo LASSO (alpha = 1) con validación cruzada
cv_model <- cv.glmnet(x, y, family = "binomial", alpha = 1, nfolds = 5)
# Modelo LASSO (alpha = 1) con validación cruzada
cv_model <- cv.glmnet(x, y, family = "binomial", alpha = 1)
# Ver coeficientes seleccionados
coef(cv_model, s = "lambda.min")
# Modelo LASSO (alpha = 1) con validación cruzada
model <- glmnet(x, y, family = "binomial", alpha = 1)
# Ver coeficientes seleccionados
coef(model, s = 0.01)  # Ajusta s para regularización más suave si necesario
# Reducir el nivel de regularización
cv_model <- cv.glmnet(x, y, family = "binomial", alpha = 1, nfolds = 3, lambda.min.ratio = 1e-5)
# Reducir el nivel de regularización
cv_model <- cv.glmnet(x, y, family = "binomial", alpha = 1, nfolds = 2, lambda.min.ratio = 1e-5)
# Reducir el nivel de regularización
cv_model <- cv.glmnet(x, y, family = "binomial", alpha = 1, lambda.min.ratio = 1e-5)
model <- glm(sex ~ ., data = cell_types, family = binomial)
summary(model)
table(cell_types$sex, cell_types$T.cells.CD4.memory.activated)
#Firth's logistic regression
install.packages("logistf")
library(logistf)
model_firth <- logistf(sex ~ ., data = cell_types)
apply(cell_types, 2, function(x) table(cell_types$sex, x))
# Ensure cell_types contains only numeric values
cell_types <- dataa[, !(names(dataa) %in% c("sample", "path", "P.value", "Correlation", "RMSE", ))]
# Ensure cell_types contains only numeric values
cell_types <- dataa[, !(names(dataa) %in% c("sample", "path", "P.value", "Correlation", "RMSE" ))]
# Correlacion entre tipos celulares y status (bipolar vs control)
#Obj: ver si hay tipos celulares que varían significativamente entre personas bipolares y controles
# test de wilcoxon para status: evalúa si los tipos celulares tienen valores diferentes y bipolares y controles
wilcox_results_status <- apply(cell_types, 2, function(x) wilcox.test(x ~dataa$status, exact = FALSE))
wilcox_results_status <- apply(cell_types, 2, function(x) wilcox.test(x ~ dataa$status, exact = FALSE))
str(cell_types)
cell_types$status_numeric <- as.numeric(cell_types$status) - 1  # "Control" -> 0, "Bipolar" -> 1
wilcox_results_status <- apply(cell_types, 2, function(x) wilcox.test(x ~ dataa$status, exact = FALSE))
wilcox_results_status <- apply(cell_types, 2, function(x) wilcox.test(x ~ dataa$status_numeric, exact = FALSE))
wilcox_results_status <- apply(cell_types, 2, function(x) wilcox.test(x ~ dataa$status_numeric, exact = FALSE))
cell_types$status_numeric <- as.numeric(cell_types$status) - 1  # "Control" -> 0, "Bipolar" -> 1
wilcox_results_status <- apply(cell_types, 2, function(x) wilcox.test(x ~ dataa$status_numeric, exact = FALSE))
cell_types$status_numeric <- as.numeric(cell_types$status) - 1  # "Control" -> 0, "Bipolar" -> 1
table(cell_types$status, cell_types$status_numeric)
wilcox_results_status <- apply(cell_types[, !names(cell_types) %in% c("status", "sex", "status_numeric")],
2,
function(x) wilcox.test(x ~ cell_types$status_numeric, exact = FALSE))
wilcox_p_values_status <- sapply(wilcox_results_status, function(x) x$p.value)
# Ver tipos celulares con diferencias significativas (p < 0.05)
significant_cells_status <- names(wilcox_p_values_status[wilcox_p_values_status < 0.05])
print(significant_cells_status)
# Verificar que p valores son NA
na_p_values <- wilcox_p_values_status[is.na(wilcox_p_values_status)]
print(na_p_values)
# Comprobar por que aparecen NA
apply(cell_types[, c("B.cells.memory", "T.cells.follicular.helper", "Macrophages.M1", "Mast.cells.activated")], 2, function(x) length(unique(x)))
View(cibersortx_results)
install.packages("flextable")
# Cargar librerías
library(dplyr)
library(flextable)
str(cell_types)
# Calcular media y desviación estándar generales
summary_table <- cell_types %>%
summarise(across(-c(status, sex), list(Mean = mean, SD = sd), na.rm = TRUE)) %>%
t() %>%
as.data.frame()
# Calcular media y desviación estándar generales
summary_table <- cell_types %>%
summarise(across(-c(status, sex),
list(Mean = \(x) mean(x, na.rm = TRUE),
SD = \(x) sd(x, na.rm = TRUE)))) %>%
t() %>%
as.data.frame()
# Renombrar columnas
colnames(summary_table) <- c("Mean", "SD")
summary_table <- cell_types %>%
summarise(across(-c(status, sex),
list(Mean = \(x) mean(x, na.rm = TRUE),
SD = \(x) sd(x, na.rm = TRUE))))
# Transponer correctamente y convertir a DataFrame
summary_table <- as.data.frame(t(summary_table))
# Ajustar nombres de columnas correctamente
colnames(summary_table) <- c("Mean", "SD")
View(summary_table)
# Cargar la librería
library(dplyr)
# Calcular media y desviación estándar para cada tipo celular (excluyendo status y sex)
summary_table <- cell_types %>%
summarise(across(-c(status, sex),
list(Mean = ~mean(.x, na.rm = TRUE),
SD = ~sd(.x, na.rm = TRUE))))
# Transponer y convertir correctamente a data frame
summary_table <- as.data.frame(t(summary_table))
# Extraer los nombres de los tipos celulares
summary_table$Cell_Type <- rownames(summary_table)
# Ajustar los nombres de las columnas correctamente
colnames(summary_table) <- c("Value", "Cell_Type")
# Separar "Mean" y "SD" en columnas distintas
summary_table <- summary_table %>%
mutate(Metric = rep(c("Mean", "SD"), length.out = nrow(summary_table))) %>%
pivot_wider(names_from = Metric, values_from = Value)
library(tidyr)  # Cargar tidyr
# Separar "Mean" y "SD" en columnas distintas
summary_table <- summary_table %>%
mutate(Metric = rep(c("Mean", "SD"), length.out = nrow(summary_table))) %>%
pivot_wider(names_from = Metric, values_from = Value)
# Reordenar para que "Cell_Type" sea la primera columna
summary_table <- summary_table[, c("Cell_Type", "Mean", "SD")]
# Ver la tabla final
print(summary_table)
# Separar "Mean" y "SD" en columnas distintas
summary_table <- cell_types %>%
summarise(across(-c(status, sex),
list(Mean = ~mean(.x, na.rm = TRUE),
SD = ~sd(.x, na.rm = TRUE)))) %>%
pivot_longer(cols = everything(), names_to = c("Cell_Type", ".value"), names_sep = "_")
workingD <- rstudioapi::getActiveDocumentContext()$path
setwd(dirname(workingD))
rm(list = ls())
# Cargar resultados de cibersortx
imp_file <- 'CIBERSORTx_Adjusted_v8.txt'
df <- read.table(imp_file, header = TRUE, sep = "\t", stringsAsFactors = FALSE)
# Eliminar la columna de ID de las muestras
df_cell_types <- df[,-c(1,24,25,26)]
# Calcular la media de expresión por tipo celular
expresion_media <- colMeans(df_cell_types)
# Generar un dataframe ordenado
ranking <- data.frame(Cell_Type = names(expresion_media),
Mean_Expression = expresion_media) %>%
arrange(desc(Mean_Expression)) # ordenadr de mayor a menor
# Imprimir los resultados
print(ranking)
# Cargar resultados de cibersortx
imp_file <- 'V9.txt'
df <- read.table(imp_file, header = TRUE, sep = "\t", stringsAsFactors = FALSE)
# Eliminar la columna de ID de las muestras
df_cell_types <- df[,-c(1,24,25,26)]
# Calcular la media de expresión por tipo celular
expresion_media <- colMeans(df_cell_types)
# Generar un dataframe ordenado
ranking <- data.frame(Cell_Type = names(expresion_media),
Mean_Expression = expresion_media) %>%
arrange(desc(Mean_Expression)) # ordenadr de mayor a menor
# Imprimir los resultados
print(ranking)
# Calcular la media y desviación estándar por tipo celular
summary_table <- df_cell_types %>%
summarise(across(everything(), list(Mean = ~mean(.x, na.rm = TRUE),
SD = ~sd(.x, na.rm = TRUE)))) %>%
pivot_longer(cols = everything(), names_to = c("Cell_Type", ".value"), names_sep = "_")
# Ordenar por mayor expresión celular
summary_table <- summary_table %>%
arrange(desc(Mean))
# Ver la tabla
print(summary_table)
# Guardar la tabla como un archivo de texto
write.table(summary_table, "cell_types_summary.txt", sep = "\t", quote = F, row.names = F, col.names = T)
# Exportar como tabla formateada para Word o PowerPoint
ft <- flextable(summary_table) %>%
theme_vanilla() %>%
autofit()
# Guardar como imagen para insertar en PowerPoint
save_as_image(ft, path = "cell_proportions_table.png")
# Guardar como imagen para insertar en PowerPoint
save_as_image(ft, path = "cell_proportions_table.jpg")
# Guardar como imagen para insertar en PowerPoint
save_as_image(ft, path = "cell_proportions_table.jpg")
# Crear la tabla con mejor formato
ft <- flextable(summary_table) %>%
theme_vanilla() %>%  # Estilo limpio
set_table_properties(width = 1, layout = "autofit") %>%  # Ajustar al contenido
fontsize(size = 12) %>%  # Aumentar tamaño de letra
bold(part = "header") %>%  # Encabezados en negrita
align(j = c("Mean", "SD"), align = "center", part = "all") %>%  # Alinear números
bg(j = 1, bg = "#DDEBF7", part = "all") %>%  # Fondo azul claro para primera columna
bg(part = "header", bg = "#4F81BD", color = "white") %>%  # Encabezado con fondo oscuro
border_remove() %>%  # Eliminar bordes internos
border(part = "all", border = fp_border(color = "black", width = 1))  # Bordes generales negros
# Crear la tabla con mejor formato
ft <- flextable(summary_table) %>%
theme_vanilla() %>%  # Estilo limpio
set_table_properties(width = 1, layout = "autofit") %>%  # Ajustar al contenido
fontsize(size = 12) %>%  # Aumentar tamaño de letra
bold(part = "header") %>%  # Encabezados en negrita
align(j = c("Mean", "SD"), align = "center", part = "all") %>%  # Alinear números
bg(j = 1, bg = "#DDEBF7", part = "all") %>%  # Fondo azul claro para primera columna
bg(part = "header", bg = "#4F81BD") %>%  # Encabezado con fondo oscuro
color(part = "header", color = "white") %>% # Color de texto blanco en el encabezado
border_remove() %>%  # Eliminar bordes internos
border(part = "all", border = fp_border(color = "black", width = 1))  # Bordes generales negros
# Calcular la media y desviación estándar por tipo celular
summary_table <- df_cell_types %>%
summarise(across(everything(), list(Mean = ~mean(.x, na.rm = TRUE),
SD = ~sd(.x, na.rm = TRUE)))) %>%
pivot_longer(cols = everything(), names_to = c("Cell_Type", ".value"), names_sep = "_")
# Ordenar por mayor expresión celular
summary_table <- summary_table %>%
arrange(desc(Mean))
# Crear la tabla con formato mejorado
ft <- flextable(summary_table) %>%
theme_vanilla() %>%  # Estilo limpio
set_table_properties(width = 1, layout = "autofit") %>%  # Ajustar ancho
fontsize(size = 12) %>%  # Aumentar tamaño de letra
bold(part = "header") %>%  # Encabezados en negrita
align(j = c("Mean", "SD"), align = "center", part = "all") %>%  # Alinear valores
bg(j = 1, bg = "#DDEBF7", part = "all") %>%  # Fondo azul claro en nombres de células
bg(part = "header", bg = "#4F81BD") %>%  # Encabezado con fondo azul oscuro
color(part = "header", color = "white") %>%  # Color de texto blanco en el encabezado
border_outer(part = "all", border = officer::fp_border(color = "black", width = 2)) %>%  # Bordes externos
border_inner_h(part = "all", border = officer::fp_border(color = "black", width = 1)) %>%  # Bordes internos horizontales
border_inner_v(part = "all", border = officer::fp_border(color = "black", width = 1))  # Bordes internos verticales
# Guardar como imagen para PowerPoint
save_as_image(ft, path = "cell_proportions_table.png")
# Guardar como archivo Word (para editar manualmente)
save_as_docx(ft, path = "cell_proportions_table.docx")
# Mostrar la tabla en RStudio
ft
# Crear la tabla con formato mejorado
ft <- flextable(summary_table) %>%
theme_vanilla() %>%  # Estilo limpio
set_table_properties(width = 1, layout = "autofit") %>%  # Ajustar ancho
fontsize(size = 12) %>%  # Aumentar tamaño de letra
bold(part = "header") %>%  # Encabezados en negrita
align(align = "center", part = "all") %>%  # Alinear valores numéricos
bg(bg = "#DDEBF7", part = "all") %>%  # Fondo azul claro en toda la tabla
bg(part = "header", bg = "#4F81BD") %>%  # Fondo azul oscuro en encabezado
color(part = "header", color = "white") %>%  # Color de texto blanco en encabezado
border_outer(part = "all", border = fp_border(color = "black", width = 2)) %>%  # Bordes externos
border_inner_h(part = "all", border = fp_border(color = "black", width = 1)) %>%  # Bordes internos horizontales
border_inner_v(part = "all", border = fp_border(color = "black", width = 1))  # Bordes internos verticales
# Crear la tabla con formato mejorado
ft_2 <- flextable(summary_table) %>%
theme_vanilla() %>%  # Estilo limpio
set_table_properties(width = 1, layout = "autofit") %>%  # Ajustar ancho automáticamente
fontsize(size = 12) %>%  # Aumentar tamaño de letra
bold(part = "header") %>%  # Encabezados en negrita
align(align = "center", part = "all") %>%  # Alinear valores numéricos
bg(bg = "#DDEBF7", part = "all") %>%  # Fondo azul claro en toda la tabla
bg(part = "header", bg = "#4F81BD") %>%  # Fondo azul oscuro en encabezado
color(part = "header", color = "white") %>%  # Color de texto blanco en encabezado
border(part = "all", border = officer::fp_border(color = "black", width = 1))  # Aplicar bordes negros
# Mostrar la tabla en RStudio
ft_2
# Guardar como imagen para PowerPoint
save_as_image(ft, path = "cell_proportions_table.png")
# Crear la tabla con formato mejorado
ft <- flextable(summary_table) %>%
theme_vanilla() %>%  # Estilo limpio
set_table_properties(width = 1, layout = "autofit") %>%  # Ajustar ancho automáticamente
fontsize(size = 12) %>%  # Aumentar tamaño de letra
bold(part = "header") %>%  # Encabezados en negrita
align(align = "center", part = "all") %>%  # Alinear valores numéricos
bg(bg = "#DDEBF7", part = "all") %>%  # Fondo azul claro en toda la tabla
bg(part = "header", bg = "#4F81BD") %>%  # Fondo azul oscuro en encabezado
color(part = "header", color = "white") %>%  # Color de texto blanco en encabezado
border(part = "all", border = officer::fp_border(color = "black", width = 1))  # Aplicar bordes negros
# Mostrar la tabla en RStudio
ft
# Guardar como archivo Word para edición manual
save_as_docx(ft, path = "cell_proportions_table.docx")
# Crear la tabla con formato mejorado
ft <- flextable(summary_table) %>%
theme_vanilla() %>%  # Estilo limpio
set_table_properties(width = 1, layout = "autofit") %>%  # Ajustar ancho automáticamente
fontsize(size = 12) %>%  # Aumentar tamaño de letra
bold(part = "header") %>%  # Encabezados en negrita
align(align = "center", part = "all") %>%  # Alinear valores numéricos
bg(j = 1:ncol(summary_table), bg = "#DDEBF7", part = "body") %>%  # Fondo azul claro en todas las columnas
bg(part = "header", bg = "#4F81BD") %>%  # Fondo azul oscuro en encabezado
color(part = "header", color = "white") %>%  # Color de texto blanco en encabezado
border(part = "all", border = officer::fp_border(color = "black", width = 1))  # Aplicar bordes negros
# Mostrar la tabla en RStudio
ft
# Guardar como imagen para PowerPoint
save_as_image(ft, path = "cell_proportions_table.png")
# Establecer directorio de trabajo al del script actual
workingD <- rstudioapi::getActiveDocumentContext()$path
setwd(dirname(workingD))
workingD <- rstudioapi::getActiveDocumentContext()$path
setwd(dirname(workingD))
rm(list = ls())  # limpia el entorno
